package main

import (
	"flag"
	"fmt"
	"io"
	"os"
)

var filename = flag.String("file", "", "output filename")

var file = io.Writer(os.Stdout)

type seq struct {
	Seq   string
	Key   string
	Code  string
	Ctrl  bool
	Alt   bool
	Shift bool
}

func p(args ...interface{}) {
	fmt.Fprintln(file, args...)
}

func (s seq) Comment() string {
	comment := s.Code
	if len(comment) == 0 {
		comment = s.Key
	}

	if s.Alt {
		comment = "Alt+" + comment
	}
	if s.Ctrl {
		comment = "Ctrl+" + comment
	}
	if s.Shift {
		comment = "Shift+" + comment
	}
	return comment
}

func (s seq) String() string {
	extra := ""
	if s.Key != "" {
		extra += fmt.Sprintf(",Key: %q", s.Key)
	}
	if s.Alt {
		extra += ", Alt: true"
	}
	if s.Ctrl {
		extra += ", Ctrl: true"
	}
	if s.Shift {
		extra += ", Shift: true"
	}
	return fmt.Sprintf("    {%q, events.KeyboardEvent{Code: %q%s}}, // %s", s.Seq, s.Code, extra, s.Comment())
}

const (
	firstASCIIChar = '!'
	lastASCIIChar  = '~'
)

func main() {
	var err error
	flag.Parse()
	if *filename != "" {
		file, err = os.Create(*filename)
		if err != nil {
			panic(err)
		}
	}
	generate()
}
func generate() {
	printWarning()
	printHeader()
	printTableStart()
	printASCII()
	printCtrl()
	printAlt()
	printCtrlAlt()
	printFandDirKeys()
	printSpecialChars()
	printTableEnd()
}

func printWarning() {
	p("// Code generated by sequencegenerator; DO NOT EDIT.\n")

}

func printHeader() {
	p("package input\n")
	p("")
	p("import (")
	p(`    "github.com/guillermo/terminal/events"`)
	p(")")
}

func printTableStart() {
	p("type seq struct{")
	p("    seq   string")
	p("    event events.Event")
	p("}\n")
	p("var sequences = []seq{")
}

func printASCII() {
	p("\n    // ASCII Chars")
	for ch := firstASCIIChar; ch <= lastASCIIChar; ch++ {
		key := string(ch)
		p(seq{Seq: key, Key: key, Code: key})
	}
}

func printCtrl() {
	p("\n    // Control Keys")
	for ch := 'A'; ch <= 'Z'; ch++ {
		s := string(ch - 'A' + 1)
		key := string(ch)
		p(seq{Seq: s, Code: key, Ctrl: true})
	}
}

func printAlt() {
	p("\n    // Alt Keys")
	for ch := firstASCIIChar; ch <= lastASCIIChar; ch++ {
		key := string(ch)
		s := "\033" + key
		p(seq{Seq: s, Code: key, Alt: true})
	}
}
func printCtrlAlt() {
	p("\n    // Control + Alt Keys")
	for ch := 'A'; ch <= 'Z'; ch++ {
		s := "\033" + string(ch-'A'+1)
		key := string(ch)
		p(seq{Seq: s, Code: key, Alt: true, Ctrl: true})
	}
}

var fnAndDir = []struct {
	Seq  string
	Code string
	// CodeSingle is required for F1-F4, as they don't follow pattern
	CodeSingle string
}{
	{Seq: "\033[%sP", Code: "F1", CodeSingle: "\033OP"},
	{Seq: "\033[%sQ", Code: "F2", CodeSingle: "\033OQ"},
	{Seq: "\033[%sR", Code: "F3", CodeSingle: "\033OR"},
	{Seq: "\033[%sS", Code: "F4", CodeSingle: "\033OS"},
	{Seq: "\033[15%s~", Code: "F5"},
	{Seq: "\033[17%s~", Code: "F6"},
	{Seq: "\033[18%s~", Code: "F7"},
	{Seq: "\033[19%s~", Code: "F8"},
	{Seq: "\033[20%s~", Code: "F9"},
	{Seq: "\033[21%s~", Code: "F10"},
	{Seq: "\033[23%s~", Code: "F11"},
	{Seq: "\033[24%s~", Code: "F12"},

	{Seq: "\033[5%s~", Code: "PageUp"},
	{Seq: "\033[6%s~", Code: "PageDown"},
	{Seq: "\033[1%sH", Code: "Home", CodeSingle: "\033[H"},
	{Seq: "\033[1%sF", Code: "End", CodeSingle: "\033[F"},
	{Seq: "\033[2%s~", Code: "Insert"},
	{Seq: "\033[3%s~", Code: "Delete"},
	{Seq: "\033[1%sA", Code: "Up", CodeSingle: "\033[A"},
	{Seq: "\033[1%sB", Code: "Down", CodeSingle: "\033[B"},
	{Seq: "\033[1%sC", Code: "Right", CodeSingle: "\033[C"},
	{Seq: "\033[1%sD", Code: "Left", CodeSingle: "\033[D"},
}

const (
	// Ctrl for the Ctrl
	Ctrl = ";5"
	// Alt for the Alt key
	Alt = ";3"
	// Shift for this Shift key
	Shift = ";2"
	// CtrlAlt for the Ctrl + Alt key
	CtrlAlt = ";7"
	// CtrlShift for the Ctrl + Shift key
	CtrlShift = ";6"
	// AltShift for the Alt + Shift key
	AltShift = ";4"
	// CtrlAltShift for the Ctrl + Alt + Shift key
	CtrlAltShift = ";8"
)

func printFandDirKeys() {
	p("\n    // Fn and directions")
	// Normal
	p("    // Normal")
	for _, fn := range fnAndDir {
		s := fn.Seq
		if fn.CodeSingle != "" {
			s = fn.CodeSingle
		} else {
			s = fmt.Sprintf(s, "")
		}
		p(seq{Seq: s, Code: fn.Code})
	}
	// Ctrl
	p("    // Ctrl")
	for _, fn := range fnAndDir {
		s := fmt.Sprintf(fn.Seq, Ctrl)
		p(seq{Seq: s, Code: fn.Code, Ctrl: true})
	}
	//Alt
	p("    // Alt")
	for _, fn := range fnAndDir {
		s := fmt.Sprintf(fn.Seq, Alt)
		p(seq{Seq: s, Code: fn.Code, Alt: true})
	}
	// Shift
	p("    // Shift")
	for _, fn := range fnAndDir {
		s := fmt.Sprintf(fn.Seq, Shift)
		p(seq{Seq: s, Code: fn.Code, Shift: true})
	}
	//CtrlAlt
	p("    // Ctrl + Alt")
	for _, fn := range fnAndDir {
		s := fmt.Sprintf(fn.Seq, CtrlAlt)
		p(seq{Seq: s, Code: fn.Code, Ctrl: true, Alt: true})
	}
	// CtrlShift
	p("    // Ctrl + Shift")
	for _, fn := range fnAndDir {
		s := fmt.Sprintf(fn.Seq, CtrlShift)
		p(seq{Seq: s, Code: fn.Code, Ctrl: true, Shift: true})
	}
	// AltShift
	p("    // Alt + Shift")
	for _, fn := range fnAndDir {
		s := fmt.Sprintf(fn.Seq, AltShift)
		p(seq{Seq: s, Code: fn.Code, Alt: true, Shift: true})
	}
	// CtrlAltShif
	p("    // Ctrl + Alt + Shift")
	for _, fn := range fnAndDir {
		s := fmt.Sprintf(fn.Seq, CtrlAltShift)
		p(seq{Seq: s, Code: fn.Code, Alt: true, Shift: true, Ctrl: true})
	}

}

// Seq Key Code Ctrl Alt
var special = []seq{
	{Seq: "\x1B", Code: "Escape"},
	{Seq: "\x1B ", Key: " ", Code: "Space", Alt: true},
	{Seq: " ", Key: " ", Code: "Space"},
	{Seq: "\000", Key: " ", Code: "Space", Ctrl: true},
	{Seq: "\x1B\000", Key: " ", Code: "Space", Ctrl: true, Alt: true},
	{Seq: "\x1c", Code: "\\", Ctrl: true},
	{Seq: "\x1d", Code: "]", Ctrl: true},

	{Seq: "\011", Code: "Tab"},
	{Seq: "\033[Z", Code: "Tab", Shift: true},
	{Seq: "\x7F", Code: "Backspace"},
	{Seq: "\010", Code: "Backspace", Ctrl: true},
	{Seq: "\x1b\x7F", Code: "Backspace", Alt: true},
	{Seq: "\x1b\010", Code: "Backspace", Alt: true, Ctrl: true},
	{Seq: "\r", Code: "Return"},
	{Seq: "\n", Code: "Return", Ctrl: true},
}

func printSpecialChars() {
	p("    // Special Keys")
	for _, c := range special {
		p(c)

	}

}

func printTableEnd() {
	p("}")
}
